<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GraphQL vs REST, which one is better? | just some developer thoughts</title><meta name=keywords content><meta name=description content="As part of my bachelor thesis I&rsquo;ve made some REST/GraphQL benchmarks that I&rsquo;ve thought some of you might find interesting. Let&rsquo;s start with short overview of both technologies.
REST Probably the most popular way of making API services right now. REST stands for Representational state transfer and APIs that follow REST rules are called &ldquo;RESTful&rdquo; APIs. In REST resource that you want to operate on is defined by some URI like http://your."><meta name=author content><link rel=canonical href=https://nxyt.pl/blog/posts/graphql_rest_comparison/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nxyt.pl/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nxyt.pl/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nxyt.pl/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://nxyt.pl/blog/apple-touch-icon.png><link rel=mask-icon href=https://nxyt.pl/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script><meta property="og:title" content="GraphQL vs REST, which one is better?"><meta property="og:description" content="As part of my bachelor thesis I&rsquo;ve made some REST/GraphQL benchmarks that I&rsquo;ve thought some of you might find interesting. Let&rsquo;s start with short overview of both technologies.
REST Probably the most popular way of making API services right now. REST stands for Representational state transfer and APIs that follow REST rules are called &ldquo;RESTful&rdquo; APIs. In REST resource that you want to operate on is defined by some URI like http://your."><meta property="og:type" content="article"><meta property="og:url" content="https://nxyt.pl/blog/posts/graphql_rest_comparison/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-27T09:03:20-08:00"><meta property="article:modified_time" content="2023-05-27T09:03:20-08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="GraphQL vs REST, which one is better?"><meta name=twitter:description content="As part of my bachelor thesis I&rsquo;ve made some REST/GraphQL benchmarks that I&rsquo;ve thought some of you might find interesting. Let&rsquo;s start with short overview of both technologies.
REST Probably the most popular way of making API services right now. REST stands for Representational state transfer and APIs that follow REST rules are called &ldquo;RESTful&rdquo; APIs. In REST resource that you want to operate on is defined by some URI like http://your."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nxyt.pl/blog/posts/"},{"@type":"ListItem","position":3,"name":"GraphQL vs REST, which one is better?","item":"https://nxyt.pl/blog/posts/graphql_rest_comparison/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GraphQL vs REST, which one is better?","name":"GraphQL vs REST, which one is better?","description":"As part of my bachelor thesis I\u0026rsquo;ve made some REST/GraphQL benchmarks that I\u0026rsquo;ve thought some of you might find interesting. Let\u0026rsquo;s start with short overview of both technologies.\nREST Probably the most popular way of making API services right now. REST stands for Representational state transfer and APIs that follow REST rules are called \u0026ldquo;RESTful\u0026rdquo; APIs. In REST resource that you want to operate on is defined by some URI like http://your.","keywords":[],"articleBody":"As part of my bachelor thesis I’ve made some REST/GraphQL benchmarks that I’ve thought some of you might find interesting. Let’s start with short overview of both technologies.\nREST Probably the most popular way of making API services right now. REST stands for Representational state transfer and APIs that follow REST rules are called “RESTful” APIs. In REST resource that you want to operate on is defined by some URI like http://your.website/user/:id and operation type is declared via HTTP method (get/post/put/delete). REST makes good use of HTTP protocol, it’s easily cacheable so it’s good choice for big websites and it’s easy to implement. In my opinion REST get’s messy once your services grows and it’s easy to have poor performance with it if your API doesn’t cover all edge cases that client’s might need (bad API design can lead to waterfalls of requests).\nGraphQL GraphQL was developed by Facebook when they were creating their mobile app. It’s meant to solve a specific problem - fetching nested and related data. Turns out that most data in any application is relational so GraphQL can be used in any service, but even if somehow your data wasn’t relational there are still benefits to GraphQL as it:\nis self documenting (easy to consume API for new people) can always fetch all necesary data in just one request has great tooling allowing for typed responses (less bugs) is easier to reason about I’d like to spend some time on the last point. If you really think about it we really do thinkings about data in term of graphs is really natural and easy. User can have Pet that has name and age. It’s easy to turn any data into tree of nodes and leaves. It’s probably subjective but I’ve easier time making GraphQL services than REST ones. With GraphQL I don’t need to think about the way my API is consumed, I just need to express all relations that node has and API consumer will pick stuff that he needs. Benchmark The goal of this benchmark is comparing performance of both protocols in semi-real world scenario. We’ll have two GraphQL servers, two REST servers, each kind of server has two implementations - naive and optimized. I’ve made two implementations as I’ve wanted to compare performance of thought out APIs and services that were quickly hacked together.\nData structure Here’s our data structure. Pretty simple, we have user table containing user information, each user belongs to some city and we also store friendships to be able to see information of every user friends.\nInitialization Benchmark starts with seedings database with random data. I’m generating 10 random cities, 1000 users and each user has 100 friends picked at random. This leaves us with ~90000 friendship relations (I’m lazy and ignored duplicate friendshipts so it’s not 1000*100).\nRequested data Requests for each implementations gather the following data (here presented in graphQL format):\nfriends { id name city { name } } In other words “whats id, name and city of all my friends”. REST implementations have two variations,\nnaive: fetches user data using /userFriends/:id to get list of friends, followed by N requests to /user/:id and /city:id to get optimized: /friendsCities/:userId to get all required data in one HTTP request (two requests to database) It’s worth noting that both naive and optimized GraphQL implementations are used by user THE SAME WAY (request at the beggining of this paragraph) so you can optimize backend without changing any frontend code. That would be much harder using REST.\nGraphQL implementations are pretty simmilar, the only difference is that optimized implementation uses data loader to\nResults I’ve testes two metrics, requests per second that server can process and total responses size. Here are results.\nRequest per second Sorry for mixing lanugages, I’m using photo made for my bachelor which was written in my native language (polish). Anyway this graph contains information about request per second that each implementation was able to process.\nResults:\nnaive REST: 14.37 rq/s naive GraphQL: 39.26 rq/s optimized REST: 500.25 rq/s optimized GraphQL: 438.78 rq/s So REST ‘won’, but at what cost. I’ve had to make inflexible endpoints made just for this specific purpose. I’m writing this article some time after making those benchmarks and coming back to see the benchmark code it was much less readable than Gql implementations. It’s worth noting that Gql optimizations will be reused in other queries automatically. I’ve used dataloader to optimize any request that fetches friends data, so now if I’d want to get informations about friends of our friends I’d need another REST endpoint, but Gql will already perform nicely.\nNaive implementation is more interesting to me. Gql achieved 2x performance without any effort. This benchmark was made in semi-real world scenario, so I’m using real database that servers fetch data from. I suspect that the reason for 2x performance is the fact that REST requests have waterfall effect. Without specialized endpoints client has to first fetch userFriends data before bombarding server with user requests to get every single friend infromation (it’s called waterfall because you need to wait for one response before making another requests). GraphQL on the other hand has less communication between server and client and all traffic happens mainly between server and database.\nResponse size Results:\nnaive REST: 81MB naive GraphQL: 18.03MB optimized REST: 19.34MB optimized GraphQL: 18.23MB As you can see even bad GraphQL implementation will have perfect score when it comes to response size. REST on the other hand suffers from overfetching that was solved in ‘optimized’ implementation, but it’ll not carry on to other queries.\nSummary GraphQL turned out to be really performant solution, that allows for very flexible access patterns which can perform well in any scenario. This benchmark didn’t touch on other subjects like caching where REST would probably have the upper hand (there are GraphQL caching solutions too though).\n","wordCount":"979","inLanguage":"en","datePublished":"2023-05-27T09:03:20-08:00","dateModified":"2023-05-27T09:03:20-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nxyt.pl/blog/posts/graphql_rest_comparison/"},"publisher":{"@type":"Organization","name":"just some developer thoughts","logo":{"@type":"ImageObject","url":"https://nxyt.pl/blog/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nxyt.pl/blog accesskey=h title="just some developer thoughts (Alt + H)">just some developer thoughts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>GraphQL vs REST, which one is better?</h1><div class=post-meta><span title='2023-05-27 09:03:20 -0800 -0800'>May 27, 2023</span></div></header><div class=post-content><p>As part of my bachelor thesis I&rsquo;ve made some REST/GraphQL benchmarks that I&rsquo;ve thought some of you might find interesting. Let&rsquo;s start with short overview of both technologies.</p><h1 id=rest>REST<a hidden class=anchor aria-hidden=true href=#rest>#</a></h1><p>Probably the most popular way of making API services right now. REST stands for <code>Representational state transfer</code> and APIs that follow REST rules are called &ldquo;RESTful&rdquo; APIs. In REST resource that you want to operate on is defined by some URI like <code>http://your.website/user/:id</code> and operation type is declared via HTTP method (get/post/put/delete). REST makes good use of HTTP protocol, it&rsquo;s easily cacheable so it&rsquo;s good choice for big websites and it&rsquo;s easy to implement. In my opinion REST get&rsquo;s messy once your services grows and it&rsquo;s easy to have poor performance with it if your API doesn&rsquo;t cover all edge cases that client&rsquo;s might need (bad API design can lead to waterfalls of requests).</p><h1 id=graphql>GraphQL<a hidden class=anchor aria-hidden=true href=#graphql>#</a></h1><p>GraphQL was developed by Facebook when they were creating their mobile app. It&rsquo;s meant to solve a specific problem - fetching nested and related data. Turns out that most data in any application is relational so GraphQL can be used in any service, but even if somehow your data wasn&rsquo;t relational there are still benefits to GraphQL as it:</p><ul><li>is self documenting (easy to consume API for new people)</li><li>can always fetch all necesary data in just one request</li><li>has great tooling allowing for typed responses (less bugs)</li><li>is easier to reason about
I&rsquo;d like to spend some time on the last point. If you really think about it we really do thinkings about data in term of graphs is really natural and easy. <code>User</code> can have <code>Pet</code> that has <code>name</code> and <code>age</code>. It&rsquo;s easy to turn any data into tree of nodes and leaves. It&rsquo;s probably subjective but I&rsquo;ve easier time making GraphQL services than REST ones. With GraphQL I don&rsquo;t need to think about the way my API is consumed, I just need to express all relations that node has and API consumer will pick stuff that he needs.</li></ul><h1 id=benchmark>Benchmark<a hidden class=anchor aria-hidden=true href=#benchmark>#</a></h1><p>The goal of this benchmark is comparing performance of both protocols in semi-real world scenario. We&rsquo;ll have two GraphQL servers, two REST servers, each kind of server has two implementations - naive and optimized. I&rsquo;ve made two implementations as I&rsquo;ve wanted to compare performance of thought out APIs and services that were quickly hacked together.</p><h2 id=data-structure>Data structure<a hidden class=anchor aria-hidden=true href=#data-structure>#</a></h2><p>Here&rsquo;s our data structure.
<img loading=lazy src=images/gql_benchmark.png alt="Data Structure">
Pretty simple, we have <code>user</code> table containing user information, each user belongs to some <code>city</code> and we also store <code>friendships</code> to be able to see information of every user friends.</p><h2 id=initialization>Initialization<a hidden class=anchor aria-hidden=true href=#initialization>#</a></h2><p>Benchmark starts with seedings database with random data. I&rsquo;m generating 10 random cities, 1000 users and each user has 100 friends picked at random. This leaves us with ~90000 friendship relations (I&rsquo;m lazy and ignored duplicate friendshipts so it&rsquo;s not 1000*100).</p><h2 id=requested-data>Requested data<a hidden class=anchor aria-hidden=true href=#requested-data>#</a></h2><p>Requests for each implementations gather the following data (here presented in graphQL format):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span>friends {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>    city {
</span></span><span style=display:flex><span>        name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In other words &ldquo;whats id, name and city of all my friends&rdquo;.
REST implementations have two variations,</p><ul><li>naive: fetches user data using <code>/userFriends/:id</code> to get list of friends, followed by N requests to <code>/user/:id</code> and <code>/city:id</code> to get</li><li>optimized: <code>/friendsCities/:userId</code> to get all required data in one HTTP request (two requests to database)</li></ul><p>It&rsquo;s worth noting that both naive and optimized GraphQL implementations are used by user <strong>THE SAME WAY</strong> (request at the beggining of this paragraph) so you can optimize backend without changing any frontend code. That would be much harder using REST.</p><p>GraphQL implementations are pretty simmilar, the only difference is that optimized implementation uses data loader to</p><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2><p>I&rsquo;ve testes two metrics, requests per second that server can process and total responses size. Here are results.</p><h3 id=request-per-second>Request per second<a hidden class=anchor aria-hidden=true href=#request-per-second>#</a></h3><p>Sorry for mixing lanugages, I&rsquo;m using photo made for my bachelor which was written in my native language (polish). Anyway this graph contains information about request per second that each implementation was able to process.</p><p><img loading=lazy src=images/req_per_second.png alt="Request per second"></p><p>Results:</p><ul><li>naive REST: 14.37 rq/s</li><li>naive GraphQL: 39.26 rq/s</li><li>optimized REST: 500.25 rq/s</li><li>optimized GraphQL: 438.78 rq/s</li></ul><p>So REST &lsquo;won&rsquo;, but at what cost. I&rsquo;ve had to make inflexible endpoints made just for this specific purpose. I&rsquo;m writing this article some time after making those benchmarks and coming back to see the benchmark code it was much less readable than Gql implementations. It&rsquo;s worth noting that Gql optimizations will be reused in other queries automatically. I&rsquo;ve used dataloader to optimize any request that fetches friends data, so now if I&rsquo;d want to get informations about friends of our friends I&rsquo;d need another REST endpoint, but Gql will already perform nicely.</p><p>Naive implementation is more interesting to me. Gql achieved 2x performance without any effort. This benchmark was made in semi-real world scenario, so I&rsquo;m using real database that servers fetch data from. I suspect that the reason for 2x performance is the fact that REST requests have waterfall effect. Without specialized endpoints client has to first fetch <code>userFriends</code> data before bombarding server with <code>user</code> requests to get every single <code>friend</code> infromation (it&rsquo;s called waterfall because you need to wait for one response before making another requests). GraphQL on the other hand has less communication between server and client and all traffic happens mainly between server and database.</p><h3 id=response-size>Response size<a hidden class=anchor aria-hidden=true href=#response-size>#</a></h3><p><img loading=lazy src=images/req_size.png alt="Response size">
Results:</p><ul><li>naive REST: 81MB</li><li>naive GraphQL: 18.03MB</li><li>optimized REST: 19.34MB</li><li>optimized GraphQL: 18.23MB</li></ul><p>As you can see even bad GraphQL implementation will have perfect score when it comes to response size. REST on the other hand suffers from overfetching that was solved in &lsquo;optimized&rsquo; implementation, but it&rsquo;ll not carry on to other queries.</p><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><p>GraphQL turned out to be really performant solution, that allows for very flexible access patterns which can perform well in any scenario. This benchmark didn&rsquo;t touch on other subjects like caching where REST would probably have the upper hand (there are GraphQL caching solutions too though).</p></div><footer class=post-footer><ul class=post-tags></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//nxyt.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://nxyt.pl/blog>just some developer thoughts</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>