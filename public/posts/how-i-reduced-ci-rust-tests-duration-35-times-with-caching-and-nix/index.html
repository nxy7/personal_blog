<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How I&#39;ve reduced CI rust tests duration 4x with caching and Nix! | just some developer thoughts</title>
<meta name="keywords" content="">
<meta name="description" content="One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we&rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15minutes. This post was made to help people struggling with simmilar issues.
Project Structure The way I structure my projects will influence some of the futhurer solutions, so I thought it&rsquo;s worthwhile sharing">
<meta name="author" content="">
<link rel="canonical" href="https://nxy7.github.io/personal_blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/">
<link crossorigin="anonymous" href="/personal_blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/personal_blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://nxy7.github.io/personal_blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nxy7.github.io/personal_blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nxy7.github.io/personal_blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nxy7.github.io/personal_blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://nxy7.github.io/personal_blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-D4BXHY930J', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="How I&#39;ve reduced CI rust tests duration 4x with caching and Nix!" />
<meta property="og:description" content="One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we&rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15minutes. This post was made to help people struggling with simmilar issues.
Project Structure The way I structure my projects will influence some of the futhurer solutions, so I thought it&rsquo;s worthwhile sharing" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nxy7.github.io/personal_blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-20T09:03:20-08:00" />
<meta property="article:modified_time" content="2023-04-20T09:03:20-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How I&#39;ve reduced CI rust tests duration 4x with caching and Nix!"/>
<meta name="twitter:description" content="One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we&rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15minutes. This post was made to help people struggling with simmilar issues.
Project Structure The way I structure my projects will influence some of the futhurer solutions, so I thought it&rsquo;s worthwhile sharing"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://nxy7.github.io/personal_blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "How I've reduced CI rust tests duration 4x with caching and Nix!",
      "item": "https://nxy7.github.io/personal_blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How I've reduced CI rust tests duration 4x with caching and Nix!",
  "name": "How I\u0027ve reduced CI rust tests duration 4x with caching and Nix!",
  "description": "One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we\u0026rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15minutes. This post was made to help people struggling with simmilar issues.\nProject Structure The way I structure my projects will influence some of the futhurer solutions, so I thought it\u0026rsquo;s worthwhile sharing",
  "keywords": [
    
  ],
  "articleBody": "One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we’re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15minutes. This post was made to help people struggling with simmilar issues.\nProject Structure The way I structure my projects will influence some of the futhurer solutions, so I thought it’s worthwhile sharing\n# in this case all backend services all written in rust backend: - serviceA - serviceB - serviceC frontend: - NodeJS Project # to make CI jobs testable locally I prefere to make scripts for them and run scripts from github workflows. # I'm using nushell as my script shell and not bash so you will have to scripts: - ci_tests script - other scripts... Test script As I’ve mentioned above I’m running tests from scripts locally and invoking scripts files in CI. Here’s how my current ci_tests.nu script file looks like. You might not be fammiliar with nushell (it’s a shell but also a scripting language) but I’m sure you can get the general idea.\n#!/usr/bin/env nu\ruse ./utils.nu;\rlet services = [\r{folder: \"frontend\", lang: \"node\"},\r{folder: \"backend/payouts\", lang: \"rust\"},\r{folder: \"backend/stream_chat\", lang: \"rust\"},\r{folder: \"backend/main\", lang: \"rust\"},\r]\r# run tests for all services\rexport def main [] {\rlet root = (utils project-root);\rcd $root;\rci-setup\rbuild-rust-workspace\r$\"(ansi green_bold)Starting tests(ansi reset)\\n\\n\"\rlet total_start_time = (date now);\rlet testResults = ($services | par-each {|service|\rcd $service.folder\rmut test = null\rlet start_time = (date now);\rif ($service.lang == \"rust\") {\r$test = (\rdo { test-rust } | complete\r)\r} else if ($service.lang == \"node\") {\r$test = (\rdo { test-node } | complete\r)\r}\rlet end_time = (date now);\rlet duration = ($end_time - $start_time);\rmut res = {\"service\": $service.folder, \"test_result\": $test, \"duration\": $duration}\rif ($test.exit_code != 0) {\r$res = ($res | insert status ❌)\r$\"($service.folder) failed\"\r} else {\r$res = ($res | insert status ✅)\r$\"($service.folder) passed\"\r}\rreturn $res\r})\rlet total_end_time = (date now);\rlet total_test_time = ($total_end_time - $total_start_time);\r$testResults | select service status duration\rmut allPassed = true\rfor res in $testResults {\rif ($res.status != \"✅\") {\r$allPassed = false\r$res.test_result\r}\r}\rif ($allPassed == false) {\rerror make {msg: $\"(ansi red_bold)Some tests failed. Total test time: ($total_test_time)\"}\r} else {\r$\"(ansi green_bold)All tests passed in ($total_test_time)\"\r}\r}\rdef test-rust [] {\rcargo nextest r\r}\rdef test-node [] {\rpnpm test\r}\rdef ci-setup [] {\rif ((\".env\" | path exists) == false) {\rcp .env.example .env;\r\"Copied .env.example to .env\"\r}\r}\rdef build-rust-workspace [] {\r$\"(ansi mb)Starting to build rust workspace\"\rlet start_time = (date now);\rlet build_backend = {|| cd backend; cargo build --all };\rlet build_res = (do $build_backend | complete);\rlet end_time = (date now)\rlet total = ($end_time - $start_time)\r$\"(ansi mb)Built rust workspace in ($total)\"\r} This script gives me really nice output in my CI Solution There are two main techniques that I’ve used to reduce CI times.\nNix to manage project dependencies Cache rust build artifacts and project dependencies (managed by nix) Arguably you can get away with just caching, but I think the two really go well together.\nNix Nix describes itself as tool that takes a unique approach to package management and system configuration.. You don’t need to use it as system configuration tool to get rewards from it’s ecosystem. In short: nix allows you to specify your projects dependencies and let anyone run your project from any machine. Imagine you clone your project onto machine that doesn’t have rust or nodejs installed. With nix you can specify your project dependencies in flake.nix file (there are other ways but nix seems to head toward using flakes) and run one command nix develop . -c bash to get shell with all dependencies ready to use. If that doesn’t sound awsome to you I don’t know what will.\nWithout getting into internals of nix, when you run command above nix will download ALL dependencies needed by your project into ’nix store’, that we can later cache in CI. Thanks to that if your project relies on rust, your CI will download rust only once and reuse it in futhurer CI runs.\nHere’s how my flake.nix file looks like\n{ description = \"A very basic flake\"; inputs = { nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\"; flakeUtils.url = \"github:numtide/flake-utils\"; }; outputs = { self, nixpkgs, flakeUtils }: flakeUtils.lib.eachSystem [ \"x86_64-linux\" ] (system: let pkgs = import nixpkgs { inherit system; }; in { devShells.default = pkgs.mkShell { packages = with pkgs; [ ]; }; devShells.ci = pkgs.mkShell { packages = with pkgs; [ rustc nushell cargo bash cargo-nextest pkg-config openssl.dev clippy nodejs-slim nodePackages_latest.pnpm ]; }; }); } There are many resources on nix flakes, but all You need to know for now is the fact that with this flake when i run nix develop .#ci -c $SHELL nix will make development shell for me looking for devShells.ci.packages list where all my dependencies are listed. I’m using $SHELL env variable as custom command, so I immiedietly start running my default shell - Nushell.\nAs you can see my dev dependencies include: rustc, nushell, cargo, nodejs and pnpm. I list all dependencies that my scripts or services might need here so it can be built both locally and in CI.\nOne additional benefit of using nix is that my test script can be run in CI and locally with the same effect (kind of). There’s option to run nix develop command with -i flag to ignore environment. If you use this option shell that you get in CI and on your local machine should be pretty much identical and hopefully output of those tests should be the same. There are some caveats tho, I didn’t find any good way to get docker into shell scope yet and my tests rely on testcontainers so for now I’m not using ‘ignore environment option’.\nTo use nix in my CI use the following workflow action\n- uses: cachix/install-nix-action@v20 with: nix_path: nixpkgs=channel:nixos-unstable extra_nix_config: | store = /home/runner/nix keep-outputs = true keep-derivations = true Setting store inside /home/runner is actually pretty important here, if You don’t do that You might run into some permissions issues when trying to save data from cache.\nCaching Github has actions that make caching very easy. I use cache/restore and cache/save actions to manage my cache. Here’s my workflows/tests.yml file, I’ll later explain parts related to caching.\nname: Tests on: push: # test runner environment variables env: CARGO_TERM_COLOR: always SQLX_OFFLINE: true jobs: tests: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Restore Nix Store id: restore-nix-cache uses: actions/cache/restore@v3 with: path: | /home/runner/nix key: ${{ runner.os }}-${{ hashFiles('./flake.nix', './flake.lock') }} - name: Restore Incremental Builds id: restore-cargo-cache uses: actions/cache/restore@v3 with: path: | ~/.cargo/bin/ ~/.cargo/registry/index/ ~/.cargo/registry/cache/ ~/.cargo/git/db/ ./backend/target key: ${{ runner.os }}-cargo-${{ hashFiles('./backend/Cargo.lock') }} - uses: cachix/install-nix-action@v20 with: nix_path: nixpkgs=channel:nixos-unstable extra_nix_config: | # save space on disk and in cache # auto-optimise-store = true store = /home/runner/nix # keep all store paths necessary to build the outputs keep-outputs = true keep-derivations = true - name: Run Tests run: | nix develop .#ci -c nu ./scripts/ci_tests.nu - name: Save nix store uses: actions/cache/save@v3 if: ${{ steps.restore-nix-cache.outputs.cache-hit == false }} with: key: ${{ runner.os }}-${{ hashFiles('./flake.nix', './flake.lock') }} path: | /home/runner/nix - name: Save incremental builds cache uses: actions/cache/save@v3 if: ${{ steps.restore-cargo-cache.outputs.cache-hit == false }} with: key: ${{ runner.os }}-cargo-${{ hashFiles('./backend/Cargo.lock') }} path: | ~/.cargo/bin/ ~/.cargo/registry/index/ ~/.cargo/registry/cache/ ~/.cargo/git/db/ ./backend/target As You can see, actually running tests is the shortest part of the whole thing:\n- name: Run Tests run: | nix develop .#ci -c nu ./scripts/ci_tests.nu This line runs nix develop .#ci command, which brings developer dependencies from devshell named “ci” into scope and -c nu ./scripts/ci_tests.nu executes nushell script from the beggining of this post. I find it easier to hack around script file rather than executing bunch of “runs:” in workflow yaml file.\nAnyway let’s see how we can reuse nix dependencies and rust build artifacts.\n- name: Restore Nix Store id: restore-nix-cache uses: actions/cache/restore@v3 with: path: | /home/runner/nix key: ${{ runner.os }}-${{ hashFiles('./flake.nix', './flake.lock') }} - name: Restore Incremental Builds id: restore-cargo-cache uses: actions/cache/restore@v3 with: path: | ~/.cargo/bin/ ~/.cargo/registry/index/ ~/.cargo/registry/cache/ ~/.cargo/git/db/ ./backend/target key: ${{ runner.os }}-cargo-${{ hashFiles('./backend/Cargo.lock') }} I split caching into two steps because otherwise we wouldn’t be able to reuse nix/cargo cache if the other one changes. Let’s read caching step line by line. name: Restore Nix Store - Set step name displayed in CI id: restore-nix-cache - set step ID, it’s usefull so we can reference outputs of the step later on uses: actions/cache/restore@v3 - use actionts/cache/restore action with: - run action with the following parameters path: |\r/home/runner/nix - we want to load cache into /home/runner/nix folder that we specified as nix store folder when setting up nix in CI key: ${{ runner.os }}-${{ hashFiles('./flake.nix', './flake.lock') }} - every cache needs key associated with it. It’s necesarry so Your CI knows which cache should it load. As all our project dependencies are listed in flake.nix i create my key as combinantion of runner system and hash of flake.nix+flake.lock. This way if I add dependency and drop it later on my flake.nix+flake.lock hash should be the same and I’ll reuse older cache.\nRestoring cache for rust build artifact works the same, we just specify more paths and use different hash in “key” propety.\nNow, when You run this workflow for the first time there obviously will be no cache to load, we need to take care of that. The following part of workflow takes care of it.\n- name: Save nix store uses: actions/cache/save@v3 if: ${{ steps.restore-nix-cache.outputs.cache-hit == false }} with: key: ${{ runner.os }}-${{ hashFiles('./flake.nix', './flake.lock') }} path: | /home/runner/nix - name: Save incremental builds cache uses: actions/cache/save@v3 if: ${{ steps.restore-cargo-cache.outputs.cache-hit == false }} with: key: ${{ runner.os }}-cargo-${{ hashFiles('./backend/Cargo.lock') }} path: | ~/.cargo/bin/ ~/.cargo/registry/index/ ~/.cargo/registry/cache/ ~/.cargo/git/db/ ./backend/target Let’s again break it into lines (but I’ll skip steps explained earlier): uses: actions/cache/save@v3 - this time we use cache/save action if: ${{ steps.restore-nix-cache.outputs.cache-hit == false }} - Save action first compresses cache and then tries to save it. Github CI caches are immutable, so if no dependencies changed and build artifacts are the same we’ll produce the same hash, which results in the same cache key. This won’t fly and CI will waste ~30sec on compressing caches that it cannot save. Because of this I’m checking if cache/restore found cache in earlier steps and if it did we’re not saving any cache. If we change ‘flake.nix’, ‘flake.lock’, or ‘cargo.lock’ files, we’ll produce different cache and we’ll be able to save it. path: | /home/runner/nix - paths we want to save to cache\nAdditional ‘hacks’ I’m running tests in parallel using nushell built in par-each function Rust tests are ran with cargo nextest, which supposedly is faster, but I didn’t compare it to cargo test myself Results Before: After: I think those are great results, especially considering that I run more tests now, so I think I might have gained more than 4x speed. Hope that someone finds this post helpful. Have a great day :-)\n",
  "wordCount" : "1876",
  "inLanguage": "en",
  "datePublished": "2023-04-20T09:03:20-08:00",
  "dateModified": "2023-04-20T09:03:20-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nxy7.github.io/personal_blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "just some developer thoughts",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nxy7.github.io/personal_blog/favicon.ico"
    }
  }
}
</script>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-D4BXHY930J', { 'anonymize_ip': false });
}
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nxy7.github.io/personal_blog" accesskey="h" title="just some developer thoughts (Alt + H)">just some developer thoughts</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      How I&#39;ve reduced CI rust tests duration 4x with caching and Nix!
    </h1>
    <div class="post-meta"><span title='2023-04-20 09:03:20 -0800 -0800'>April 20, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we&rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15minutes. This post was made to help people struggling with simmilar issues.</p>
<h1 id="project-structure">Project Structure<a hidden class="anchor" aria-hidden="true" href="#project-structure">#</a></h1>
<p>The way I structure my projects will influence some of the futhurer solutions, so I thought it&rsquo;s worthwhile sharing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>    <span style="color:#75715e"># in this case all backend services all written in rust</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">backend</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">serviceA</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">serviceB</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">serviceC</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">frontend</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">NodeJS Project</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># to make CI jobs testable locally I prefere to make scripts for them and run scripts from github workflows.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># I&#39;m using nushell as my script shell and not bash so you will have to </span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">scripts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">ci_tests script</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">other scripts...</span>
</span></span></code></pre></div><h1 id="test-script">Test script<a hidden class="anchor" aria-hidden="true" href="#test-script">#</a></h1>
<p>As I&rsquo;ve mentioned above I&rsquo;m running tests from scripts locally and invoking scripts files in CI. Here&rsquo;s how my current ci_tests.nu script file looks like. You  might not be fammiliar with nushell (it&rsquo;s a shell but also a scripting language) but I&rsquo;m sure you can get the general idea.</p>
<pre tabindex="0"><code class="language-nushell" data-lang="nushell">#!/usr/bin/env nu
use ./utils.nu;

let services = [
  {folder: &#34;frontend&#34;, lang: &#34;node&#34;},
  {folder: &#34;backend/payouts&#34;, lang: &#34;rust&#34;},
  {folder: &#34;backend/stream_chat&#34;, lang: &#34;rust&#34;},
  {folder: &#34;backend/main&#34;, lang: &#34;rust&#34;},
]

# run tests for all services
export def main [] {
    let root = (utils project-root);
    cd $root;

    ci-setup
    build-rust-workspace


    $&#34;(ansi green_bold)Starting tests(ansi reset)\n\n&#34;
    let total_start_time = (date now);
    let testResults = ($services | par-each {|service|
      cd $service.folder

      mut test = null
      let start_time = (date now);
      if ($service.lang == &#34;rust&#34;) {
        $test = (
          do { test-rust } | complete
        )
      } else if ($service.lang == &#34;node&#34;) {
        $test = (
          do { test-node } | complete
        )
      }
      let end_time = (date now);
      let duration = ($end_time - $start_time);

      mut res = {&#34;service&#34;: $service.folder, &#34;test_result&#34;: $test, &#34;duration&#34;: $duration}
      if ($test.exit_code != 0) {
        $res = ($res | insert status ❌)
        $&#34;($service.folder) failed&#34;
      } else {
        $res = ($res | insert status ✅)
        $&#34;($service.folder) passed&#34;
      }
      return $res
    })
    let total_end_time = (date now);
    let total_test_time = ($total_end_time - $total_start_time);

    $testResults | select service status duration

    mut allPassed = true
    for res in $testResults {
      if ($res.status != &#34;✅&#34;) {
        $allPassed = false
        $res.test_result
      }
    }

    if ($allPassed == false) {
      error make {msg: $&#34;(ansi red_bold)Some tests failed. Total test time: ($total_test_time)&#34;}
    } else {
      $&#34;(ansi green_bold)All tests passed in ($total_test_time)&#34;
    }
}

def test-rust [] {
  cargo nextest r
}

def test-node [] {
  pnpm test
}

def ci-setup [] {
  if ((&#34;.env&#34; | path exists) == false) {
    cp .env.example .env;
    &#34;Copied .env.example to .env&#34;
  }
}

def build-rust-workspace [] {
    $&#34;(ansi mb)Starting to build rust workspace&#34;
    let start_time = (date now);
    let build_backend = {|| cd backend; cargo build --all };
    let build_res = (do $build_backend | complete);
    let end_time = (date now)
    let total = ($end_time - $start_time)
    $&#34;(ansi mb)Built rust workspace in ($total)&#34;
}
</code></pre><p>This script gives me really nice output in my CI
<img loading="lazy" src="https://i.imgur.com/NonjwGm.png" alt="CI Pipeline output"  />
</p>
<h1 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h1>
<p>There are two main techniques that I&rsquo;ve used to reduce CI times.</p>
<ul>
<li>Nix to manage project dependencies</li>
<li>Cache rust build artifacts and project dependencies (managed by nix)</li>
</ul>
<p>Arguably you can get away with just caching, but I think the two really go well together.</p>
<h2 id="nix">Nix<a hidden class="anchor" aria-hidden="true" href="#nix">#</a></h2>
<p>Nix describes itself as <code>tool that takes a unique approach to package management and system configuration.</code>. You don&rsquo;t need to use it as system configuration tool to get rewards from it&rsquo;s ecosystem. In short: nix allows you to specify your projects dependencies and let anyone run your project from any machine. Imagine you clone your project onto machine that doesn&rsquo;t have rust or nodejs installed. With nix you can specify your project dependencies in flake.nix file (there are other ways but nix seems to head toward using flakes) and run one command <code>nix develop . -c bash</code> to get shell with all dependencies ready to use. If that doesn&rsquo;t sound awsome to you I don&rsquo;t know what will.</p>
<p>Without getting into internals of nix, when you run command above nix will download ALL dependencies needed by your project into &rsquo;nix store&rsquo;, that we can later cache in CI. Thanks to that if your project relies on rust, your CI will download rust only once and reuse it in futhurer CI runs.</p>
<p>Here&rsquo;s how my flake.nix file looks like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A very basic flake&#34;</span>;
</span></span><span style="display:flex;"><span>  inputs <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    nixpkgs<span style="color:#f92672">.</span>url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;github:NixOS/nixpkgs/nixpkgs-unstable&#34;</span>;
</span></span><span style="display:flex;"><span>    flakeUtils<span style="color:#f92672">.</span>url <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;github:numtide/flake-utils&#34;</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  outputs <span style="color:#f92672">=</span> { self<span style="color:#f92672">,</span> nixpkgs<span style="color:#f92672">,</span> flakeUtils }:
</span></span><span style="display:flex;"><span>    flakeUtils<span style="color:#f92672">.</span>lib<span style="color:#f92672">.</span>eachSystem [ <span style="color:#e6db74">&#34;x86_64-linux&#34;</span> ] (system:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">let</span> pkgs <span style="color:#f92672">=</span> <span style="color:#f92672">import</span> nixpkgs { <span style="color:#66d9ef">inherit</span> system; };
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">in</span> {
</span></span><span style="display:flex;"><span>        devShells<span style="color:#f92672">.</span>default <span style="color:#f92672">=</span> pkgs<span style="color:#f92672">.</span>mkShell { packages <span style="color:#f92672">=</span> <span style="color:#66d9ef">with</span> pkgs; [ ]; };
</span></span><span style="display:flex;"><span>        devShells<span style="color:#f92672">.</span>ci <span style="color:#f92672">=</span> pkgs<span style="color:#f92672">.</span>mkShell {
</span></span><span style="display:flex;"><span>          packages <span style="color:#f92672">=</span> <span style="color:#66d9ef">with</span> pkgs; [
</span></span><span style="display:flex;"><span>            rustc
</span></span><span style="display:flex;"><span>            nushell
</span></span><span style="display:flex;"><span>            cargo
</span></span><span style="display:flex;"><span>            bash
</span></span><span style="display:flex;"><span>            cargo-nextest
</span></span><span style="display:flex;"><span>            pkg-config
</span></span><span style="display:flex;"><span>            openssl<span style="color:#f92672">.</span>dev
</span></span><span style="display:flex;"><span>            clippy
</span></span><span style="display:flex;"><span>            nodejs-slim
</span></span><span style="display:flex;"><span>            nodePackages_latest<span style="color:#f92672">.</span>pnpm
</span></span><span style="display:flex;"><span>          ];
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>      });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are many resources on nix flakes, but all You need to know for now is the fact that with this flake when i run <code>nix develop .#ci -c $SHELL</code> nix will make development shell for me looking for devShells.ci.packages list where all my dependencies are listed. I&rsquo;m using $SHELL env variable as custom command, so I immiedietly start running my default shell - Nushell.</p>
<p>As you can see my dev dependencies include: rustc, nushell, cargo, nodejs and pnpm. I list all dependencies that my scripts or services might need here so it can be built both locally and in CI.</p>
<p>One additional benefit of using nix is that my test script can be run in CI and locally with the same effect (kind of). There&rsquo;s option to run <code>nix develop</code> command with <code>-i</code> flag to ignore environment. If you use this option shell that you get in CI and on your local machine should be pretty much identical and hopefully output of those tests should be the same. There are some caveats tho, I didn&rsquo;t find any good way to get docker into shell scope yet and my tests rely on testcontainers so for now I&rsquo;m not using &lsquo;ignore environment option&rsquo;.</p>
<p>To use nix in my CI use the following workflow action</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>      - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">cachix/install-nix-action@v20</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">nix_path</span>: <span style="color:#ae81ff">nixpkgs=channel:nixos-unstable</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">extra_nix_config</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            store = /home/runner/nix
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            keep-outputs = true
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            keep-derivations = true</span>            
</span></span></code></pre></div><p>Setting store inside /home/runner is actually pretty important here, if You don&rsquo;t do that You might run into some permissions issues when trying to save data from cache.</p>
<h2 id="caching">Caching<a hidden class="anchor" aria-hidden="true" href="#caching">#</a></h2>
<p>Github has actions that make caching very easy. I use <em>cache/restore</em> and <em>cache/save</em> actions to manage my cache. Here&rsquo;s my workflows/tests.yml file, I&rsquo;ll later explain parts related to caching.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">name</span>: <span style="color:#ae81ff">Tests</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">on</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">push</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># test runner environment variables</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">CARGO_TERM_COLOR</span>: <span style="color:#ae81ff">always</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">SQLX_OFFLINE</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">jobs</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">tests</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">runs-on</span>: <span style="color:#ae81ff">ubuntu-latest</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">steps</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v3</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Restore Nix Store</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">id</span>: <span style="color:#ae81ff">restore-nix-cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/restore@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /home/runner/nix</span>            
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-${{ hashFiles(&#39;./flake.nix&#39;, &#39;./flake.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Restore Incremental Builds</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">id</span>: <span style="color:#ae81ff">restore-cargo-cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/restore@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/bin/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/index/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/cache/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/git/db/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ./backend/target</span>            
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-cargo-${{ hashFiles(&#39;./backend/Cargo.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">cachix/install-nix-action@v20</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">nix_path</span>: <span style="color:#ae81ff">nixpkgs=channel:nixos-unstable</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">extra_nix_config</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            # save space on disk and in cache
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            # auto-optimise-store = true
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            store = /home/runner/nix
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            # keep all store paths necessary to build the outputs
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            keep-outputs = true
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            keep-derivations = true</span>            
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Run Tests</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          nix develop .#ci -c nu ./scripts/ci_tests.nu</span>          
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Save nix store</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/save@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ steps.restore-nix-cache.outputs.cache-hit == false }}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-${{ hashFiles(&#39;./flake.nix&#39;, &#39;./flake.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /home/runner/nix</span>            
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Save incremental builds cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/save@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ steps.restore-cargo-cache.outputs.cache-hit == false }}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-cargo-${{ hashFiles(&#39;./backend/Cargo.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/bin/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/index/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/cache/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/git/db/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ./backend/target</span>            
</span></span></code></pre></div><p>As You can see, actually running tests is the shortest part of the whole thing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Run Tests</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          nix develop .#ci -c nu ./scripts/ci_tests.nu</span>          
</span></span></code></pre></div><p>This line runs <code>nix develop .#ci</code> command, which brings developer dependencies from devshell named &ldquo;ci&rdquo; into scope and <code>-c nu ./scripts/ci_tests.nu</code> executes nushell script from the beggining of this post. I find it easier to hack around script file rather than executing bunch of &ldquo;runs:&rdquo; in workflow yaml  file.</p>
<p>Anyway let&rsquo;s see how we can reuse nix dependencies and rust build artifacts.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Restore Nix Store</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">id</span>: <span style="color:#ae81ff">restore-nix-cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/restore@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /home/runner/nix</span>            
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-${{ hashFiles(&#39;./flake.nix&#39;, &#39;./flake.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Restore Incremental Builds</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">id</span>: <span style="color:#ae81ff">restore-cargo-cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/restore@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/bin/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/index/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/cache/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/git/db/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ./backend/target</span>            
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-cargo-${{ hashFiles(&#39;./backend/Cargo.lock&#39;) }}</span>
</span></span></code></pre></div><p>I split caching into two steps because otherwise we wouldn&rsquo;t be able to reuse nix/cargo cache if the other one changes. Let&rsquo;s read caching step line by line.
<code>name: Restore Nix Store</code> - Set step name displayed in CI
<code>id: restore-nix-cache</code> - set step ID, it&rsquo;s usefull so we can reference outputs of the step later on
<code>uses: actions/cache/restore@v3</code> - use actionts/cache/restore action
<code>with:</code> - run action with the following parameters
<code>path: | /home/runner/nix</code> - we want to load cache into /home/runner/nix folder that we specified as nix store folder when setting up nix in CI
<code>key: ${{ runner.os }}-${{ hashFiles('./flake.nix', './flake.lock') }}</code> - every cache needs key associated with it. It&rsquo;s necesarry so Your CI knows which cache should it load. As all our project dependencies are listed in flake.nix i create my key as combinantion of runner system and hash of flake.nix+flake.lock. This way if I add dependency and drop it later on my flake.nix+flake.lock hash should be the same and I&rsquo;ll reuse older cache.</p>
<p>Restoring cache for rust build artifact works the same, we just specify more paths and use different hash in &ldquo;key&rdquo; propety.</p>
<p>Now, when You run this workflow for the first time there obviously will be no cache to load, we need to take care of that. The following part of workflow takes care of it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Save nix store</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/save@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ steps.restore-nix-cache.outputs.cache-hit == false }}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-${{ hashFiles(&#39;./flake.nix&#39;, &#39;./flake.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /home/runner/nix</span>            
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Save incremental builds cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache/save@v3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ steps.restore-cargo-cache.outputs.cache-hit == false }}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-cargo-${{ hashFiles(&#39;./backend/Cargo.lock&#39;) }}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/bin/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/index/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/registry/cache/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ~/.cargo/git/db/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ./backend/target</span>            
</span></span></code></pre></div><p>Let&rsquo;s again break it into lines (but I&rsquo;ll skip steps explained earlier):
<code>uses: actions/cache/save@v3</code> - this time we use cache/save action
<code>if: ${{ steps.restore-nix-cache.outputs.cache-hit == false }}</code> - Save action first compresses cache and then tries to save it. Github CI caches are immutable, so if no dependencies changed and build artifacts are the same we&rsquo;ll produce the same hash, which results in the same cache key. This won&rsquo;t fly and CI will waste ~30sec on compressing caches that it cannot save. Because of this I&rsquo;m checking if <em>cache/restore</em> found cache in earlier steps and if it did we&rsquo;re not saving any cache. If we change &lsquo;flake.nix&rsquo;, &lsquo;flake.lock&rsquo;, or &lsquo;cargo.lock&rsquo; files, we&rsquo;ll produce different cache and we&rsquo;ll be able to save it.
<code>path: | /home/runner/nix</code> - paths we want to save to cache</p>
<h3 id="additional-hacks">Additional &lsquo;hacks&rsquo;<a hidden class="anchor" aria-hidden="true" href="#additional-hacks">#</a></h3>
<ul>
<li>I&rsquo;m running tests in parallel using nushell built in par-each function</li>
<li>Rust tests are ran with cargo nextest, which supposedly is faster, but I didn&rsquo;t compare it to cargo test myself</li>
</ul>
<h1 id="results">Results<a hidden class="anchor" aria-hidden="true" href="#results">#</a></h1>
<p>Before:
<img loading="lazy" src="https://i.imgur.com/HkBvqDN.png" alt=""  />

After:
<img loading="lazy" src="https://i.imgur.com/V9JRWi4.png" alt=""  />
</p>
<p>I think those are great results, especially considering that I run more tests now, so I think I might have gained more than 4x speed. Hope that someone finds this post helpful. Have a great day :-)</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "nxyt" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://nxy7.github.io/personal_blog">just some developer thoughts</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
